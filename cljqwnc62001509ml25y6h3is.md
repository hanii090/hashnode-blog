---
title: "Programming is Easy, Software Development is Hard & Maintaining Code is the Hardest"
datePublished: Thu Jul 06 2023 08:47:47 GMT+0000 (Coordinated Universal Time)
cuid: cljqwnc62001509ml25y6h3is
slug: programming-is-easy-software-development-is-hard-maintaining-code-is-the-hardest
tags: software-development, programming-blogs, developer, codenewbies, 2023

---

First of all, if you are a fan of black-and-white, clear-cut distinctions, then you're reading about the wrong topic.

In the tech world, the lines between many roles are blurred; like *“*[***PHP Ninja Dev***](https://www.mendeley.com/careers/job/php-ninja-developer-1292294)*”*.

Just have a look at the job roles in the Data Science Industry.

> Roles like Data Analyst, Business Analyst, and Data Engineer are spelled differently on paper, but most companies expect roughly the same kind of work out of all three roles —\_ just take my word for it, I have worked as a professional Data Engineer Ninja Scientist (Don,t quote me on that).\_

For the most part, what these “titles” mean depends purely on how the company you work for interprets it.

But let,s not get distracted, I,m not here to discuss the nuances of how these titles are different from each other — *I don't know much about that honestly.*

---

About 3 years ago, I started my journey as an Entrepreneur and assumed the role of a “Tech Lead” at my startup.

This meant that I had to start learning some newer technologies like **React** & **NextJs Solidity** especially if I expected to deliver any kind of software that people would willingly pay for.

*“Surely that won't be too hard?” —* It was extremely hard, like sailing through the second level of hell.

## **Programming Is Easy, But Software Development Is Hard.**

Software development is hard because most people usually tend to skip the foundational steps, which is learning to create programs that do things that other people want to pay for, and all the difficulties that entail.

I come from a background in competitive coding.

But that didn't teach me anything about developing a software product with the right UX and design choices, integrating several complex APIs, or writing code for role-based authorization logic.

When I started developing our first software product ([DreamyRooms](https://dreamyrooms.vercel.app/)), I felt like a kid who was expecting to write an essay right after learning the alphabet.

Moreover, I didn't,t have the luxury of taking a few month's breaks from my business to master these technologies since I had already committed to a deadline, therefore I was only left with one choice — *to learn and implement all these technologies in our product on the go.*

> It took me about 7 months to deliver this product.

During that period, I learned that software development is a very complicated process that cannot be learned by simply following a tutorial.

In order to be a successful software developer, I needed to not only write code but also understand how that code works and interacts with the rest of the system.

While it sounds easy, I can assure you that there are only a handful of videos on YouTube that can teach you this skill.

Because understanding the nuances of how different technologies/frameworks operate together is something that can not be learned by watching a tutorial video — ***It is something one must learn by*** *“****doing”.***

It required me to familiarise myself with new concepts and terminologies/frameworks.

I spent more time reading through documentation, or watching video explanations to try and fill the gaps in my knowledge rather than writing actual lines of code!

*( I found* [***this video***](https://www.youtube.com/watch?v=jsYBiB6Vt9w) *by Delba de Oliveira to be one of the best introductions to the React paradigm. )*

After spending all that time learning, I realized that most tutorials sucked at explaining the actual process of Software Development.

## **Most tutorials and courses did a great job of abstracting away the complexities of software development by teaching me only the** [**primitives**](https://en.wikipedia.org/wiki/Language_primitive#:~:text=In%20computing%2C%20language%20primitives%20are,an%20expression%20in%20a%20language.)**.**

They made learning & mastering a language or framework seem very easy — *to the point that it made me wonder what the fuss is all about.*

There is a huge disconnect between what is shown in tutorials, blogs, and courses and what is actually used in enterprise-grade applications.

And, in my opinion, this seems to be the biggest reason why it takes people months or sometimes even years to reach the end of their software development cycles.

For example, most React tutorials teach you how to read data from external [**REST APIs**](https://www.redhat.com/en/topics/api/what-is-a-rest-api#:~:text=A%20REST%20API%20%28also%20known,by%20computer%20scientist%20Roy%20Fielding.), but very few videos talk about the importance of using [**React Query**](https://react-query.tanstack.com/) — which is a hook library that eliminates repetitive code and introduces production-ready data fetching and caching practices ready to be implemented out-of-the-box.

Almost every real-world application would require you to build out the logic for data fetching and in most cases would require the use of something like [**React Query**](https://react-query.tanstack.com/).

By the time I had made this realization, I had to go back and re-write almost 2000 lines of code within an application that was otherwise ready to be launched in a month — *it was either that, or I would have to spend weeks debugging and optimizing my application/servers after delivery which would have been very time-consuming.*

## **The process of Software Development is a combination of a dozen or so important decisions that one needs to make before writing even one line of code.**

You have to think about your architecture, database design, tech stack, cloud hosting, and caching and even that is barely scratching the surface.

> *Software Development is a complicated process that requires you to understand various domain-specific concepts, specifications, testing, scaling, setting timelines, designing the architecture and most importantly choosing your “tech stack” like cloud service providers\*.\**

Since I had no prior experience in developing software, thinking about architecture or choosing the right tech stack; my journey was a little rough.

After going back and forth for about 4 months, and writing nearly 20,000 lines of code, the software development was finally completed… although, the journey was still far from over.

I was now faced with a new set of challenges — **Maintenance.**

Maintaining software is a topic that has had very little light shed on it by experienced developers of the world.

If you, ve ever tried to update or fix a piece of code that someone else wrote, you would know how frustrating it can get.

There are a variety of reasons why it can be hard to maintain code, but some of the most common reasons are:

1. The code is difficult to understand or is poorly written.
    
2. The code is not well organized and it is difficult to find the code you need.
    
3. The code has been modified so many times that it is difficult to track down the original source code.
    
4. The code is no longer supported by the original author or the company that owns the code.
    

## **The complexity of code maintenance is one of the main reasons for the high failure rate of software projects.**

In order to keep a software system running smoothly, the code must be constantly updated and tweaked to account for changes in the business environment, new requirements, and advances in technology.

This is a daunting task, and it,s often difficult to find the time and resources to do it properly.

As a result, many software systems become bogged down with legacy code that,s difficult to update and maintain.

Eventually, this would lead to performance issues and security vulnerabilities.

We battled these issues early on during our development by focusing our efforts on writing code in modules (breaking it up into smaller, reusable components), and reusing them to reduce the amount of code that needs to be rewritten or updated each time there is a change in the business environment or system requirements.

Planning out our modules in advance is something that helped us address the problems associated with code maintenance and made the process easier and more efficient.

It saved us a lot of time and money, and it also helped ensure that our code is more reliable and secure.

---

In conclusion, Software Development & Maintenance are heavily misunderstood topics.

Their complexities are not understood by inexperienced developers because they usually lack the depth of expertise needed.

**It is something you will learn once you dive into the deep end of software development & delivery.**